{"version":3,"sources":["webpack:///./node_modules/vue-waterfall/lib/waterfall.vue?9fa3","webpack:///./node_modules/vue-waterfall/lib/waterfall.vue?c4db","webpack:///node_modules/vue-waterfall/lib/waterfall.vue","webpack:///./node_modules/vue-waterfall/lib/waterfall.vue?f83c","webpack:///./node_modules/vue-waterfall/lib/waterfall.vue"],"names":["_mini_css_extract_plugin_dist_loader_js_css_loader_index_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_vue_loader_lib_index_js_vue_loader_options_waterfall_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","n","MOVE_CLASS_PROP","waterfallvue_type_script_lang_js_","props","autoResize","default","interval","validator","val","align","indexOf","line","lineGap","required","minLineGap","maxLineGap","singleMaxWidth","fixedHeight","grow","Array","watch","data","style","height","overflow","token","methods","reflowHandler","clearTimeout","this","setTimeout","reflow","autoResizeHandler","on","window","off","_this2","$el","width","clientWidth","metas","$children","map","slot","getMeta","sort","a","b","order","virtualRects","calculate","el","rects","metasNeedToMoveByTransform","filter","meta","moveClass","firstRects","getRects","forEach","rect","i","node","prop","vm","applyRects","lastRects","firstRect","lastRect","dx","dy","sw","sh","left","top","transform","WebkitTransform","concat","transitionDuration","document","body","elem","name","RegExp","test","attr","hasClass","cur","trim","res","addClass","waterfallvue_type_script_lang_js_render","$emit","created","_this","$on","$watch","mounted","getTransitionEndEvent","tidyUpAnimations","beforeDestroy","event","reg","target","replace","styles","options","Math","max","getOptions","horizontalLineProcessor","verticalLineProcessor","strategy","total","sum","count","length","getRowStrategyWithGrow","slotWidth","maxContentWidth","minGreedyContentWidth","canFit","canFitGreedy","round","min","getArrayFillWith","getLeft","getRowStrategy","tops","index","offset","reduce","last","slice","apply","greedyCount","rowWidth","rowHeight","getGreedyCount","lazyCount","greedySize","getContentSize","finalSize","lazySize","cost","Infinity","chooseFinalSize","fitContentWidth","originWidth","fitHeight","abs","contentWidth","arr","undefined","ontransitionend","onwebkittransitionend","item","getter","value","getAttribute","setAttribute","type","listener","useCapture","arguments","addEventListener","removeEventListener","lib_waterfallvue_type_script_lang_js_","component","Object","componentNormalizer","_h","$createElement","_self","_c","staticClass","_t","__file","__webpack_exports__"],"mappings":"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","file":"66.chunk.25487146.js","sourcesContent":["import mod from \"-!../../mini-css-extract-plugin/dist/loader.js!../../css-loader/index.js??ref--3-oneOf-1-1!../../vue-loader/lib/loaders/stylePostLoader.js!../../postcss-loader/src/index.js??ref--3-oneOf-1-2!../../vue-loader/lib/index.js??vue-loader-options!./waterfall.vue?vue&type=style&index=0&lang=css&\"; export default mod; export * from \"-!../../mini-css-extract-plugin/dist/loader.js!../../css-loader/index.js??ref--3-oneOf-1-1!../../vue-loader/lib/loaders/stylePostLoader.js!../../postcss-loader/src/index.js??ref--3-oneOf-1-2!../../vue-loader/lib/index.js??vue-loader-options!./waterfall.vue?vue&type=style&index=0&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vue-waterfall\",style:(_vm.style)},[_vm._t(\"default\")],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n  <div class=\"vue-waterfall\" :style=\"style\">\r\n    <slot></slot>\r\n  </div>\r\n</template>\r\n\r\n<style>\r\n.vue-waterfall {\r\n  position: relative;\r\n  /*overflow: hidden; cause clientWidth = 0 in IE if height not bigger than 0 */\r\n}\r\n</style>\r\n\r\n<script>\r\n\r\nconst MOVE_CLASS_PROP = '_wfMoveClass'\r\n\r\nexport default {\r\n  props: {\r\n    autoResize: {\r\n      default: true\r\n    },\r\n    interval: {\r\n      default: 200,\r\n      validator: (val) => val >= 0\r\n    },\r\n    align: {\r\n      default: 'left',\r\n      validator: (val) => ~['left', 'right', 'center'].indexOf(val)\r\n    },\r\n    line: {\r\n      default: 'v',\r\n      validator: (val) => ~['v', 'h'].indexOf(val)\r\n    },\r\n    lineGap: {\r\n      required: true,\r\n      validator: (val) => val >= 0\r\n    },\r\n    minLineGap: {\r\n      validator: (val) => val >= 0\r\n    },\r\n    maxLineGap: {\r\n      validator: (val) => val >= 0\r\n    },\r\n    singleMaxWidth: {\r\n      validator: (val) => val >= 0\r\n    },\r\n    fixedHeight: {\r\n      default: false\r\n    },\r\n    grow: {\r\n      validator: (val) => val instanceof Array\r\n    },\r\n    watch: {\r\n      default: () => ({})\r\n    }\r\n  },\r\n  data: () => ({\r\n    style: {\r\n      height: '',\r\n      overflow: ''\r\n    },\r\n    token: null\r\n  }),\r\n  methods: {\r\n    reflowHandler,\r\n    autoResizeHandler,\r\n    reflow\r\n  },\r\n  created () {\r\n    this.virtualRects = []\r\n    this.$on('reflow', () => {\r\n      this.reflowHandler()\r\n    })\r\n    this.$watch(() => (\r\n      this.align,\r\n      this.line,\r\n      this.lineGap,\r\n      this.minLineGap,\r\n      this.maxLineGap,\r\n      this.singleMaxWidth,\r\n      this.fixedHeight,\r\n      this.watch\r\n    ), this.reflowHandler)\r\n    this.$watch('grow', this.reflowHandler)\r\n  },\r\n  mounted () {\r\n    this.$watch('autoResize', this.autoResizeHandler)\r\n    on(this.$el, getTransitionEndEvent(), tidyUpAnimations, true)\r\n    this.autoResizeHandler(this.autoResize)\r\n  },\r\n  beforeDestroy () {\r\n    this.autoResizeHandler(false)\r\n    off(this.$el, getTransitionEndEvent(), tidyUpAnimations, true)\r\n  }\r\n}\r\n\r\nfunction autoResizeHandler (autoResize) {\r\n  if (autoResize === false || !this.autoResize) {\r\n    off(window, 'resize', this.reflowHandler, false)\r\n  } else {\r\n    on(window, 'resize', this.reflowHandler, false)\r\n  }\r\n}\r\n\r\nfunction tidyUpAnimations (event) {\r\n  let node = event.target\r\n  let moveClass = node[MOVE_CLASS_PROP]\r\n  if (moveClass) {\r\n    removeClass(node, moveClass)\r\n  }\r\n}\r\n\r\nfunction reflowHandler () {\r\n  clearTimeout(this.token)\r\n  this.token = setTimeout(this.reflow, this.interval)\r\n}\r\n\r\nfunction reflow () {\r\n  if (!this.$el) { return }\r\n  let width = this.$el.clientWidth\r\n  let metas = this.$children.map((slot) => slot.getMeta())\r\n  metas.sort((a, b) => a.order - b.order)\r\n  this.virtualRects = metas.map(() => ({}))\r\n  calculate(this, metas, this.virtualRects)\r\n  setTimeout(() => {\r\n    if (isScrollBarVisibilityChange(this.$el, width)) {\r\n      calculate(this, metas, this.virtualRects)\r\n    }\r\n    this.style.overflow = 'hidden'\r\n    render(this.virtualRects, metas)\r\n    this.$emit('reflowed', this)\r\n  }, 0)\r\n}\r\n\r\nfunction isScrollBarVisibilityChange (el, lastClientWidth) {\r\n  return lastClientWidth !== el.clientWidth\r\n}\r\n\r\nfunction calculate (vm, metas, styles) {\r\n  let options = getOptions(vm)\r\n  let processor = vm.line === 'h' ? horizontalLineProcessor : verticalLineProcessor\r\n  processor.calculate(vm, options, metas, styles)\r\n}\r\n\r\nfunction getOptions (vm) {\r\n  const maxLineGap = vm.maxLineGap ? +vm.maxLineGap : vm.lineGap\r\n  return {\r\n    align: ~['left', 'right', 'center'].indexOf(vm.align) ? vm.align : 'left',\r\n    line: ~['v', 'h'].indexOf(vm.line) ? vm.line : 'v',\r\n    lineGap: +vm.lineGap,\r\n    minLineGap: vm.minLineGap ? +vm.minLineGap : vm.lineGap,\r\n    maxLineGap: maxLineGap,\r\n    singleMaxWidth: Math.max(vm.singleMaxWidth || 0, maxLineGap),\r\n    fixedHeight: !!vm.fixedHeight,\r\n    grow: vm.grow && vm.grow.map(val => +val)\r\n  }\r\n}\r\n\r\nvar verticalLineProcessor = (() => {\r\n\r\n  function calculate (vm, options, metas, rects) {\r\n    let width = vm.$el.clientWidth\r\n    let grow = options.grow\r\n    let strategy = grow\r\n      ? getRowStrategyWithGrow(width, grow)\r\n      : getRowStrategy(width, options)\r\n    let tops = getArrayFillWith(0, strategy.count)\r\n    metas.forEach((meta, index) => {\r\n      let offset = tops.reduce((last, top, i) => top < tops[last] ? i : last, 0)\r\n      let width = strategy.width[offset % strategy.count]\r\n      let rect = rects[index]\r\n      rect.top = tops[offset]\r\n      rect.left = strategy.left + (offset ? sum(strategy.width.slice(0, offset)) : 0)\r\n      rect.width = width\r\n      rect.height = meta.height * (options.fixedHeight ? 1 : width / meta.width)\r\n      tops[offset] = tops[offset] + rect.height\r\n    })\r\n    vm.style.height = Math.max.apply(Math, tops) + 'px'\r\n  }\r\n\r\n  function getRowStrategy (width, options) {\r\n    let count = width / options.lineGap\r\n    let slotWidth\r\n    if (options.singleMaxWidth >= width) {\r\n      count = 1\r\n      slotWidth = Math.max(width, options.minLineGap)\r\n    } else {\r\n      let maxContentWidth = options.maxLineGap * ~~count\r\n      let minGreedyContentWidth = options.minLineGap * ~~(count + 1)\r\n      let canFit = maxContentWidth >= width\r\n      let canFitGreedy = minGreedyContentWidth <= width\r\n      if (canFit && canFitGreedy) {\r\n        count = Math.round(count)\r\n        slotWidth = width / count\r\n      } else if (canFit) {\r\n        count = ~~count\r\n        slotWidth = width / count\r\n      } else if (canFitGreedy) {\r\n        count = ~~(count + 1)\r\n        slotWidth = width / count\r\n      } else {\r\n        count = ~~count\r\n        slotWidth = options.maxLineGap\r\n      }\r\n      if (count === 1) {\r\n        slotWidth = Math.min(width, options.singleMaxWidth)\r\n        slotWidth = Math.max(slotWidth, options.minLineGap)\r\n      }\r\n    }\r\n    return {\r\n      width: getArrayFillWith(slotWidth, count),\r\n      count: count,\r\n      left: getLeft(width, slotWidth * count, options.align)\r\n    }\r\n  }\r\n\r\n  function getRowStrategyWithGrow (width, grow) {\r\n    let total = sum(grow)\r\n    return {\r\n      width: grow.map(val => width * val / total),\r\n      count: grow.length,\r\n      left: 0\r\n    }\r\n  }\r\n\r\n  return {\r\n    calculate\r\n  }\r\n\r\n})()\r\n\r\nvar horizontalLineProcessor = (() => {\r\n\r\n  function calculate (vm, options, metas, rects) {\r\n    let width = vm.$el.clientWidth\r\n    let total = metas.length\r\n    let top = 0\r\n    let offset = 0\r\n    while (offset < total) {\r\n      let strategy = getRowStrategy(width, options, metas, offset)\r\n      for (let i = 0, left = 0, meta, rect; i < strategy.count; i++) {\r\n        meta = metas[offset + i]\r\n        rect = rects[offset + i]\r\n        rect.top = top\r\n        rect.left = strategy.left + left\r\n        rect.width = meta.width * strategy.height / meta.height\r\n        rect.height = strategy.height\r\n        left += rect.width\r\n      }\r\n      offset += strategy.count\r\n      top += strategy.height\r\n    }\r\n    vm.style.height = top + 'px'\r\n  }\r\n\r\n  function getRowStrategy (width, options, metas, offset) {\r\n    let greedyCount = getGreedyCount(width, options.lineGap, metas, offset)\r\n    let lazyCount = Math.max(greedyCount - 1, 1)\r\n    let greedySize = getContentSize(width, options, metas, offset, greedyCount)\r\n    let lazySize = getContentSize(width, options, metas, offset, lazyCount)\r\n    let finalSize = chooseFinalSize(lazySize, greedySize, width)\r\n    let height = finalSize.height\r\n    let fitContentWidth = finalSize.width\r\n    if (finalSize.count === 1) {\r\n      fitContentWidth = Math.min(options.singleMaxWidth, width)\r\n      height = metas[offset].height * fitContentWidth / metas[offset].width\r\n    }\r\n    return {\r\n      left: getLeft(width, fitContentWidth, options.align),\r\n      count: finalSize.count,\r\n      height: height\r\n    }\r\n  }\r\n\r\n  function getGreedyCount (rowWidth, rowHeight, metas, offset) {\r\n    let count = 0\r\n    for (let i = offset, width = 0; i < metas.length && width <= rowWidth; i++) {\r\n      width += metas[i].width * rowHeight / metas[i].height\r\n      count++\r\n    }\r\n    return count\r\n  }\r\n\r\n  function getContentSize (rowWidth, options, metas, offset, count) {\r\n    let originWidth = 0\r\n    for (let i = count - 1; i >= 0; i--) {\r\n      let meta = metas[offset + i]\r\n      originWidth += meta.width * options.lineGap / meta.height\r\n    }\r\n    let fitHeight = options.lineGap * rowWidth / originWidth\r\n    let canFit = (fitHeight <= options.maxLineGap && fitHeight >= options.minLineGap)\r\n    if (canFit) {\r\n      return {\r\n        cost: Math.abs(options.lineGap - fitHeight),\r\n        count: count,\r\n        width: rowWidth,\r\n        height: fitHeight\r\n      }\r\n    } else {\r\n      let height = originWidth > rowWidth ? options.minLineGap : options.maxLineGap\r\n      return {\r\n        cost: Infinity,\r\n        count: count,\r\n        width: originWidth * height / options.lineGap,\r\n        height: height\r\n      }\r\n    }\r\n  }\r\n\r\n  function chooseFinalSize (lazySize, greedySize, rowWidth) {\r\n    if (lazySize.cost === Infinity && greedySize.cost === Infinity) {\r\n      return greedySize.width < rowWidth ? greedySize : lazySize\r\n    } else {\r\n      return greedySize.cost >= lazySize.cost ? lazySize : greedySize\r\n    }\r\n  }\r\n\r\n  return {\r\n    calculate\r\n  }\r\n\r\n})()\r\n\r\nfunction getLeft (width, contentWidth, align) {\r\n  switch (align) {\r\n    case 'right':\r\n      return width - contentWidth\r\n    case 'center':\r\n      return (width - contentWidth) / 2\r\n    default:\r\n      return 0\r\n  }\r\n}\r\n\r\nfunction sum (arr) {\r\n  return arr.reduce((sum, val) => sum + val)\r\n}\r\n\r\nfunction render (rects, metas) {\r\n  let metasNeedToMoveByTransform = metas.filter((meta) => meta.moveClass)\r\n  let firstRects = getRects(metasNeedToMoveByTransform)\r\n  applyRects(rects, metas)\r\n  let lastRects = getRects(metasNeedToMoveByTransform)\r\n  metasNeedToMoveByTransform.forEach((meta, i) => {\r\n    meta.node[MOVE_CLASS_PROP] = meta.moveClass\r\n    setTransform(meta.node, firstRects[i], lastRects[i])\r\n  })\r\n  document.body.clientWidth // forced reflow\r\n  metasNeedToMoveByTransform.forEach((meta) => {\r\n    addClass(meta.node, meta.moveClass)\r\n    clearTransform(meta.node)\r\n  })\r\n}\r\n\r\nfunction getRects (metas) {\r\n  return metas.map((meta) => meta.vm.rect)\r\n}\r\n\r\nfunction applyRects (rects, metas) {\r\n  rects.forEach((rect, i) => {\r\n    let style = metas[i].node.style\r\n    metas[i].vm.rect = rect\r\n    for (let prop in rect) {\r\n      style[prop] = rect[prop] + 'px'\r\n    }\r\n  })\r\n}\r\n\r\nfunction setTransform (node, firstRect, lastRect) {\r\n  let dx = firstRect.left - lastRect.left\r\n  let dy = firstRect.top - lastRect.top\r\n  let sw = firstRect.width / lastRect.width\r\n  let sh = firstRect.height / lastRect.height\r\n  node.style.transform =\r\n  node.style.WebkitTransform = `translate(${dx}px,${dy}px) scale(${sw},${sh})`\r\n  node.style.transitionDuration = '0s'\r\n}\r\n\r\nfunction clearTransform (node) {\r\n  node.style.transform = node.style.WebkitTransform = ''\r\n  node.style.transitionDuration = ''\r\n}\r\n\r\nfunction getTransitionEndEvent () {\r\n  let isWebkitTrans =\r\n    window.ontransitionend === undefined &&\r\n    window.onwebkittransitionend !== undefined\r\n  let transitionEndEvent = isWebkitTrans\r\n    ? 'webkitTransitionEnd'\r\n    : 'transitionend'\r\n  return transitionEndEvent\r\n}\r\n\r\n/**\r\n * util\r\n */\r\n\r\nfunction getArrayFillWith (item, count) {\r\n  let getter = (typeof item === 'function') ? () => item() : () => item\r\n  let arr = []\r\n  for (let i = 0; i < count; i++) {\r\n    arr[i] = getter()\r\n  }\r\n  return arr\r\n}\r\n\r\nfunction addClass (elem, name) {\r\n  if (!hasClass(elem, name)) {\r\n    let cur = attr(elem, 'class').trim()\r\n    let res = (cur + ' ' + name).trim()\r\n    attr(elem, 'class', res)\r\n  }\r\n}\r\n\r\nfunction removeClass (elem, name) {\r\n  let reg = new RegExp('\\\\s*\\\\b' + name + '\\\\b\\\\s*', 'g')\r\n  let res = attr(elem, 'class').replace(reg, ' ').trim()\r\n  attr(elem, 'class', res)\r\n}\r\n\r\nfunction hasClass (elem, name) {\r\n  return (new RegExp('\\\\b' + name + '\\\\b')).test(attr(elem, 'class'))\r\n}\r\n\r\nfunction attr (elem, name, value) {\r\n  if (typeof value !== 'undefined') {\r\n    elem.setAttribute(name, value)\r\n  } else {\r\n    return elem.getAttribute(name) || ''\r\n  }\r\n}\r\n\r\nfunction on (elem, type, listener, useCapture = false) {\r\n  elem.addEventListener(type, listener, useCapture)\r\n}\r\n\r\nfunction off (elem, type, listener, useCapture = false) {\r\n  elem.removeEventListener(type, listener, useCapture)\r\n}\r\n\r\n</script>\r\n","import mod from \"-!../../babel-loader/lib/index.js??ref--2-0!../../vue-loader/lib/index.js??vue-loader-options!./waterfall.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../babel-loader/lib/index.js??ref--2-0!../../vue-loader/lib/index.js??vue-loader-options!./waterfall.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./waterfall.vue?vue&type=template&id=2353f8c4&\"\nimport script from \"./waterfall.vue?vue&type=script&lang=js&\"\nexport * from \"./waterfall.vue?vue&type=script&lang=js&\"\nimport style0 from \"./waterfall.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\ncomponent.options.__file = \"waterfall.vue\"\nexport default component.exports"],"sourceRoot":""}